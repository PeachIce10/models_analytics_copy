What your stack needs to run all models via IaC

Compute & Runtime
	•	Containers: Build images for each job under analytics/jobs/** and for signals/cmd.
	•	Orchestrator: Kubernetes (CronJobs for batch; Deployments for services) or equivalent.
	•	Artifact registry: Store versioned images for jobs and the signals service.
	•	Schedulers: One CronJob per model job; pass config via env/ConfigMap/Secret.

Data Stores & Schemas
	•	Core inputs: Postgres and/or ClickHouse DSNs for reads per configs/*.yaml.
	•	Outputs: Postgres tables for customer_segments, product_signals; ClickHouse for affinity_edges if chosen.
	•	Indexes: Add keys on id + model_version + as_of per schemas/models/*.json.
	•	Retention/backups: Enable backups and retention on Postgres/ClickHouse.

Config & Secrets
	•	Runtime configs: Mount analytics/configs/*.yaml (jobs) and signals.yaml (serving).
	•	Secrets: Env vars for DSNs (CORE_PG_DSN, CORE_CH_DSN, SIGNALS_PG_DSN, SIGNALS_CH_DSN).
	•	SLOs: Honor freshness_hours, min_rows, timeouts_ms defined in signals.yaml.

Batch Jobs (analytics/jobs)
	•	Entrypoints: cmd/main.go loads config → runs pipeline/*.go → calls *_validate.go → upserts.
	•	Windows: Use common/timewin/window.go for last_30d/90d/180d etc.
	•	Datastore helpers: Implement reads/writes in common/datastore/{postgres.go,clickhouse.go}.
	•	SLOs: Enforce job_slo (timeout, retries, backoff) per job in the process context.
	•	Idempotency: Upsert on (id, model_version, as_of); dedupe in *_validate.go.

Serving Layer (signals/)
	•	Service: Deploy signals as a long-running service (gRPC + GraphQL).
	•	Store factory: Bind datasets to stores per signals/internal/store/factory.go.
	•	Validators: Enforce paging limits and required fields in signals/internal/validators/*.
	•	Schemas & resolvers: Expose customer_segments, product_signals, affinity_edges via GraphQL and proto.

Monitoring & Ops (from safety.yaml)
	•	Boot checks: Ping stores, verify mappings, check freshness/row count; fail fast on error.
	•	Health: Expose /healthz and /readyz on signals with SLO awareness.
	•	Ops API: Add opsStatus GraphQL for dashboard status.
	•	Metrics: Emit gauges/counters (boot ok, dataset ok, rows, maxAgeHours, job rows, job runtime).
	•	Logs: One boot line with bindings; per-job completion lines with rows and duration.

Security & Access
	•	Network: Allow signals and jobs to reach Postgres/ClickHouse over private endpoints.
	•	IAM/roles: Least-privilege DB roles; read-only for serving; read+write for jobs.
	•	Secrets mgmt: Kubernetes Secrets or cloud secret manager; never hardcode DSNs.

CI/CD
	•	Build: go build for each job binary and for signals; dockerize.
	•	Test: Lint configs; ensure signals.yaml parses and bindings exist.
	•	Deploy: Apply Terraform/Pulumi for DBs, networks, clusters, and K8s manifests for jobs/services.
	•	Versioning: Tag images with model version; propagate into configs/<model>.yaml.

Model-Specific Notes
	•	#1 CLV (BG/NBD + Gamma-Gamma): Add a small fitting routine (once per store/segment) to estimate r, α, a, b, p, q, γ; store in config or a small table; use same job pattern.
	•	#2/#7/#12 Similarity/ANN (optional): If you choose ANN, provision FAISS/Milvus/OpenSearch-kNN and load vectors; otherwise serve co-buy cosine from tables.
	•	#8 RankNet (optional train): If you train pairwise weights offline, add a training job and persist weights; scoring runs in service or batch.
	•	All jobs: Keep money in cents; enforce store/tenant scoping in datastore helpers.

Operational Runbooks
	•	Backfill: Trigger jobs with a specific window and model_version via ad-hoc CronJob runs.
	•	Staleness: Check opsStatus; rerun affected job; confirm upserts.
	•	Schema drift: Update schemas/models/*.json, add DB migration, bump model_version.

Bottom line: containerize jobs, wire DSNs and configs, schedule with CronJobs, serve via signals, and enforce the SLO/health rules from safety.yaml.