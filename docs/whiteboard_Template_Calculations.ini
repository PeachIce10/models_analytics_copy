Start
A) One-time pre-flight (used for all 15 models)

1) Data sources (where values come from)
	•	orders: order_id, user_id, items{product_id, qty, price}, discounts, returns, subtotal, total, created_at.
	•	products: product_id, brand_id, category_id, base_price, margin, stock_cover_days, attributes.
	•	events (nav): session_id, user_id?, page_type, product_id, action{view, click, fav, atc, search}, ts, referrer, channel.
	•	customers: user_id, created_at, email perms, last_login.
	•	price_history: sku, week, price, promo_flag.
	•	search_logs: query, impressions, clicks, purchases, features.
	•	campaign_logs: arm, send_ts, open/click, convert.
	•	support (optional): tickets, NPS flags.

Note: map these to app features you mentioned (product_feature, order_feature, customer_feature, etc.).

2) Identity & scope
	•	user (known): user_id + store_id; per-customer outputs (CLV, churn, personas, affinities, lifecycle).
	•	visitor (anon): session_id; cohort features (segment, channel, page). Use fallback hierarchy: user → cohort → tenant default.
	•	tenant split: all jobs partition by store_id (and merchant_id where needed).

3) Metric classes (how values are obtained)
	•	Raw: timestamps, amounts (cents), product/category/brand ids, quantities, channel, referrer.
	•	Derived: AOV, frequency, recency, stock cover, co-buy counts, cosine, time-decay counts.
	•	Extrapolated: fitted params/weights (e.g., RankNet, churn), BG/NBD hypergeometric term, optimization output (markdown plan, bundles).

4) Parameters/coefficients (what’s “known” vs “learned”)
	•	Fixed knobs: horizons H, windows W, floors/caps, guardrails (λ, α, N), tier thresholds.
	•	Tenant-level learned params: CLV (r, α, a, b, p, q, γ), RankNet weights, churn/upsell coefficients, cross-sell β’s.
	•	Update cadence: train weekly (params table), score daily (outputs). Latest per store_id.

5) Flows (where models apply online)
	•	PDP: #7 Similarity, #12 Cross-sell, #2 Recommender.
	•	PLP/Search: #8 Rank, #2 Recommender.
	•	Cart/Checkout: #3 Basket re-rank, #11 Upsell.
	•	Email/Promo: #4 Promotion Uplift (assign offline; serve to orchestration).
	•	Global personalization: #6 Affinities, #5 Personas, #1 CLV, #14 Churn, #15 Lifecycle (usually offline; optional serve).

6) Units, keys, SLOs
	•	Money: cents only. Probabilities: [0,1].
	•	Keys: (id, model_version, as_of, store_id).
	•	Freshness: PG datasets ≤36h; CH edges ≤72h.

⸻

B) Per-model whiteboard template (copy this 15×)

Model # / Name / Goal
Inputs (tables → fields, tenant scope)
Known params (fixed knobs)
Learned params (if any) + cadence
Core expression (plain English, then symbol if needed)
Decision rule / Score
Guardrails (caps, λ, stock, excludes)
Outputs (dataset → columns): { primary_id(s), fields…, model_version, as_of, store_id }
Serving (Y/N; query name if Y)
Cron: Fit (Y/N, weekly), Score (daily)
Unit checks: cents/probs/ranges
Notes: visitor fallback (cohort) if user unknown

⸻

C) CSV mock sheets you should draft (for whiteboard demos)
	•	orders.csv: order_id, user_id?, product_id, qty, price_cents, discount_cents, returned, created_at, store_id.
	•	events.csv: session_id, user_id?, page_type, product_id, action, ts, channel, store_id.
	•	products.csv: product_id, brand_id, category_id, base_price_cents, margin_cents, stock_cover_days.
	•	search_logs.csv: query, product_id, clicked (0/1), features…, store_id.
	•	price_history.csv: sku, week, price_cents, promo_flag, store_id.

⸻

D) Gaps you should add (so we don’t get blocked later)
	•	Visitor cohorts: simple session → cohort builder (channel, device, referrer, page mix) → visitor_cohorts table.
	•	Customer signals (optional richer nav): per-customer aggregates (views_by_brand/category, click_depth, email_engaged) → customer_signals.
	•	Params tables: <model>_params per tenant for any model with learned coefficients.

⸻

E) Quick mapping: which models need richer nav/context
	•	Needs nav/session: #2, #3, #7, #8, #11, #12.
	•	Benefits from nav: #5 Personas, #6 Affinities, #14 Churn, #15 Lifecycle.
	•	Mostly transactional: #1 CLV, #9 Markdown, #10 Elasticity, #13 Bundle, #4 Uplift (with campaign logs).

⸻
End


Start
1) Visitor Cohorts (anon/session flows)

Purpose: real-time fallback when user_id is unknown; cohort-level targeting.

Add
	•	Job: jobs/customer/visitor_cohorts/{cmd/main.go, pipeline/visitor_cohorts_pipeline.go, visitor_cohorts_validate.go}
	•	Table (PG): visitor_cohorts
	•	store_id, cohort_id (hash of {channel, device, referrer, page_mix})
	•	channel, device, referrer_domain
	•	page_mix (top categories/brands in last N pages)
	•	avg_depth, bounce_rate, atc_rate, purchase_rate
	•	size, last_seen_at, as_of, model_version
	•	Inputs: events (views/clicks/ATC/checkout), products (brand/category)
	•	Cadence: daily (24h); Serving: optional GraphQL visitorCohort(cohortId)
	•	Used by: #2, #3, #7, #8, #11, #12 (runtime fallback); improves #5, #6, #14, #15 features.

2) Customer Signals (logged-in flows)

Purpose: per-user aggregates for persona/affinities/churn/lifecycle; light runtime rules.

Add
	•	Job: jobs/customer/signals/{cmd/main.go, pipeline/customer_signals_pipeline.go, customer_signals_validate.go}
	•	Table (PG): customer_signals
	•	store_id, user_id
	•	views_by_brand (jsonb top-K), views_by_category (jsonb)
	•	last_brand, last_category, last_channel
	•	email_open_rate_90d, email_click_rate_90d, email_engaged (bool)
	•	session_count_30d, atc_count_30d, purchase_count_90d
	•	avg_view_to_atc_sec, avg_atc_to_buy_sec
	•	as_of, model_version
	•	Inputs: events, orders, email/campaign logs (if available), products
	•	Cadence: daily; Serving: optional GraphQL customerSignals(userId)
	•	Used by: #5 Personas, #6 Affinities, #14 Churn, #15 Lifecycle; as features or joins. Also light rules in #3/#11/#12.

3) Parameter Tables (learned coefficients per tenant)

Pattern: train weekly → write <model>_params (PG) → scoring jobs read latest per store_id.

Add (as needed)
	•	#1 CLV: clv_params(store_id, r, alpha, a, b, p, q, gamma, as_of, model_version); job clv_fit.
	•	#8 RankNet: rank_weights(store_id, feature, weight, intercept, as_of, model_version); job ranknet_train.
	•	#12 Cross-sell: cross_sell_params(store_id, beta0..3, alpha_lsp, m0, N, as_of, model_version); job cross_sell_train (if learning).
	•	#11 Upsell: upsell_params(store_id, lambda, basegm_prior, as_of, model_version); (or learned GBM/logit coef_*).
	•	#14 Churn: churn_params(store_id, coef_*, as_of, model_version); job churn_train.
	•	#15 Lifecycle: hsmm_params(store_id, duration_means, emission_rates, as_of, model_version); job lifecycle_fit.
	•	#2 Recommender (ranker): reuse rank_weights or reco_params(store_id, coef_*, caps, as_of, model_version).
	•	#10 Elasticity: elasticity_params(store_id, priors, guardrails, as_of, model_version) (optional).
	•	#4 Uplift: uplift_params(store_id, arm_costs, caps, as_of, model_version) (if learned τ model).
	•	#9 Markdown / #13 Bundle: store policy knobs if tuned: markdown_params, bundle_params.

Cadence: train weekly; score daily.

4) DB placement (where to store & read)
	•	ClickHouse (CH): wide logs and graph edges: events, affinity_edges, heavy scans, similarity builds.
	•	Postgres (PG): serving & params: customer_segments, product_signals, tiers_clv, cross_sell, upsell_scores, bundles, markdown_plans, elasticity, personas, churn_risk, lifecycle_state, visitor_cohorts, customer_signals, all <model>_params, and rank_weights.

5) Model ↔ signals/params mapping (quick)
	•	Needs visitor cohorts runtime: #2, #3, #7, #8, #11, #12
	•	Uses customer signals features: #5, #6, #14, #15 (also boosts #3/#11/#12 rules)
	•	Has params table (learned): #1, #8, #12, #11, #14, #15 (and optionally #2, #4, #10, #9, #13 for policy)
	•	Batch-only math: #1, #4, #5, #6, #9, #10, #13, #14, #15
	•	Online serve: #2, #3, #7, #8, #11, #12 (GraphQL)

6) “Done when” checklist (so it’s automatic, per tenant)
	•	Jobs exist: visitor_cohorts (daily), customer_signals (daily), each <model>_train (weekly), each <model> scoring (daily).
	•	Tables exist (PG/CH) as above.
	•	Scoring jobs read latest <model>_params by store_id.
	•	Signals exposes only datasets needed at runtime; resolvers apply tenant/user/session context.
	•	SLOs: freshness 36h (PG) / 72h (CH) met; opsStatus green.
End
